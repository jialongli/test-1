madvise()详解
https://blog.csdn.net/wenjieky/article/details/8865272
---------------------------------------------------------------------------------------

madvise() 函数建议内核，在从 addr 指定的地址开始，长度等于 len 
参数值的范围内，该区域的用户虚拟内存应遵循特定的使用模式。
内核使用这些信息优化与指定范围关联的资源的处理和维护过程。如果使用 madvise() 
函数的程序明确了解其内存访问模式，则使用此函数可以提高系统性能。


#include <sys/types.h>
#include <sys/mman.h>
int madvise(caddr_t addr, size_t len, int advice);
madvise() 函数提供了以下标志，这些标志影响 lgroup 之间线程内存的分配方式：


MADV_ACCESS_DEFAULT	此标志将指定范围的内核预期访问模式重置为缺省设置。

MADV_ACCESS_LWP		此标志通知内核，移近指定地址范围的下一个 LWP 就是将要访问此范围次数最多的 LWP。
					内核将相应地为此范围和 LWP 分配内存和其他资源。

MADV_ACCESS_MANY	此标志建议内核，许多进程或 LWP 将在系统内随机访问指定的地址范围。
					内核将相应地为此范围分配内存和其他资源。


madvise() 函数可以返回以下值：

EAGAIN	指定地址范围（从 addr 到 addr+len）中的部分或所有映射均已锁定进行 I/O 操作。

EINVAL	addr 参数的值不是sysconf(3C) 返回的页面大小的倍数，指定地址范围的长度小于或等于零或者建议无效。

EIO	读写文件系统时发生 I/O 错误。

ENOMEM	指定地址范围中的地址不在进程的有效地址空间范围内，或者指定地址范围中的地址指定了一个或多个未映射的页面。

ESTALE	NFS 文件句柄过时。


  
mmap的作用是将硬盘文件的内容映射到内存中，采用闭链哈希建立的索引文件非常适合利用mmap的方式进行内存映射，
利用mmap返回的地址指针就是索引文件在内存中的首地址，这样我们就可以放心大胆的访问这些内容了。

      
使用过mmap映射文件的同学会发现一个问题，search程序访问对应的内存映射时，
处理query的时间会有latecny会陡升，究其原因是因为mmap只是建立了一个逻辑地址，linux的内存分配测试都
是采用延迟分配的形式，也就是只有你真正去访问时采用分配物理内存页，
并与逻辑地址建立映射，这也就是我们常说的缺页中断。  


缺页中断分为两类，一种是内存缺页中断，这种的代表是malloc，利用malloc分配的内存只有在程序访问到得时候，内存才会分配；
另外就是硬盘缺页中断，这种中断的代表就是mmap，利用mmap映射后的只是逻辑地址，
当我们的程序访问时，内核会将硬盘中的文件内容读进物理内存页中，
这里我们就会明白为什么mmap之后，访问内存中的数据延时会陡增。

      
出现问题解决问题，上述情况出现的原因本质上是mmap映射文件之后，
实际并没有加载到内存中，要解决这个文件，需要我们进行索引的预加载，这里就会引出本文讲到的另一函数madvise，
这个函数会传入一个地址指针，已经一个区间长度，madvise会向内核提供一个针对于地址区间的I/O的建议，
内核可能会采纳这个建议，会做一些预读的操作。例如 MADV_SEQUENTIAL 这个就表明顺序预读。

     
如果感觉这样还不给力，可以采用read操作，从mmap文件的首地址开始到最终位置，顺序的读
取一遍，这样可以完全保证mmap后的数据全部load到内存中。

