https://www.ctolib.com/topics-83229.html

以下是来自wiki对obstack的介绍：
Obstack是C标准库里面对内存管理的GNU扩展（实际上就是GNU C library了）。Obstack===Object 
stack。没错，Obstack就是一个栈，栈里面的元素是对象object（不是面向对象的对象哦，这里的对象单指数据元素）。
这些数据是动态的，也就是使用的是动态内存。这种内存管理技术属于Region-based memory management。


那什么叫基于区域的内存管理呢？区域指的是我们申请的数据对象存放的位置。
在这种内存管理模式下，我们将所有申请的数据对象集中放在一起（当然咯，地址不一定连续。
集中在一起是一种逻辑结构，比如Obstack的栈）。好处就是，可以一次性的释放内存，集中管理。 
这下你对Obstack有了大体上的了解了吧。


以下为GNU C的Obstack描述：
Obstack是一种内存池，内存池里面包含了数据对象栈。

啥叫内存池呢？内存池也叫做固定大小的块内存申请（fixed-size blocks 
allocation），同样也是一种内存管理技术。这种技术允许动态申请内存。（是不是迷糊了？前面还说固定，现在又说动态了。
实际上固定的是总大小，动态是指内存实际申请使用。如果你用过virtual box，没错就是那个百分之60刚玩linux的人都会安装的东西。
里面创建虚拟硬盘时对动态分配有这样的描述：虚拟磁盘只是逐渐占用物理硬盘空间[直至达到分配的大小]
，不过当其内部空间不用时不会自动缩减暂用的物理硬盘空间]
）这种方式有点类似malloc或者C++
的new操作。但是malloc和new操作都会造成内存碎片化问题（别打我，这是wiki讲的，不关我的事）。
更有效地方式就是使用 相同大小 内存池了。预先申请，集中管理。应用程序在内存池里面自由的玩耍，从来不上岸 -_-|||。
