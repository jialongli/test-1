/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 06月 14日 星期五 09:05:22 CST. */
/* 
 Copyright (C) Rong Tao @Beijing

 Permission is granted to copy, distribute and/or modify this document
 under the terms of the GNU Free Documentation License, Version 1.3
 or any later version published by the Free Software Foundation;
 with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
 Texts. A copy of the license is included in the section entitled ‘‘GNU
 Free Documentation License’’.
   2019年 03月 14日 星期四 19:24:29 CST. 
*/
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 13日 星期三 08:54:00 CST. */
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 08日 星期五 08:10:13 CST. */
/* Copyright (c) Colorado School of Mines, CST.*/
/* All rights reserved.                       */

/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 07日 星期四 20:27:51 CST. */
/* Copyright (C) Rong Tao @Sylincom Beijing, 2019年 03月 07日 星期四 20:26:57 CST. */
/*
int SIGILL [Macro]
The name of this signal is derived from “illegal instruction”; it usually means your
program is trying to execute garbage or a privileged instruction. Since the C compiler
generates only valid instructions, SIGILL typically indicates that the executable fle
is corrupted, or that you are trying to execute data. Some common ways of getting
into the latter situation are by passing an invalid object where a pointer to a function
was expected, or by writing past the end of an automatic array (or similar problems
with pointers to automatic variables) and corrupting other data on the stack such as
the return address of a stack frame.
SIGILL can also be generated when the stack overﬂows, or when the system has
trouble running the handler for a signal.
int SIGTRAP [Macro]
Generated by the machine’s breakpoint instruction, and possibly other trap instruc
tions. This signal is used by debuggers. Your program will probably only see SIGTRAP
if it is somehow executing bad instructions.
int SIGEMT [Macro]
Emulator trap; this results from certain unimplemented instructions which might be
emulated in software, or the operating system’s failure to properly emulate them.
int SIGSYS [Macro]
Bad system call; that is to say, the instruction to trap to the operating system was
executed, but the code number for the system call to perform was invalid.
int SIGILL [Macro]
The name of this signal is derived from “illegal instruction”; it usually means your
program is trying to execute garbage or a privileged instruction. Since the C compiler
generates only valid instructions, SIGILL typically indicates that the executable fle
is corrupted, or that you are trying to execute data. Some common ways of getting
into the latter situation are by passing an invalid object where a pointer to a function
was expected, or by writing past the end of an automatic array (or similar problems
with pointers to automatic variables) and corrupting other data on the stack such as
the return address of a stack frame.
SIGILL can also be generated when the stack overﬂows, or when the system has
trouble running the handler for a signal.
int SIGSEGV [Macro]
This signal is generated when a program tries to read or write outside the memory that
is allocated for it, or to write memory that can only be read. (Actually, the signals
only occur when the program goes far enough outside to be detected by the system’s
memory protection mechanism.) The name is an abbreviation for “segmentation
violation”.
Common ways of getting a SIGSEGV condition include dereferencing a null or uninitialized pointer, or when you use a pointer to step through an array, but fail to check
for the end of the array. It varies among systems whether dereferencing a null pointer
generates SIGSEGV or SIGBUS.
int SIGBUS [Macro]
This signal is generated when an invalid pointer is dereferenced. Like SIGSEGV, this
signal is typically the result of dereferencing an uninitialized pointer. The diﬀerence
between the two is that SIGSEGV indicates an invalid access to valid memory, while
SIGBUS indicates an access to an invalid address. In particular, SIGBUS signals often
result from dereferencing a misaligned pointer, such as referring to a four-word integer
at an address not divisible by four. (Each kind of computer has its own requirements
for address alignment.)
The name of this signal is an abbreviation for “bus error”.
int SIGABRT [Macro]
This signal indicates an error detected by the program itself and reported by calling
abort. See Section 25.6.4 [Aborting a Program], page 686.
int SIGIOT [Macro]
Generated by the PDP-11 “iot” instruction. On most machines, this is just another
name for SIGABRT.
 */

#include <signal.h>
#include <stdio.h>

int main()
{
	printf("NSIG = %d\n", NSIG);
	printf("SIGFPE = %d\n", SIGFPE);
	printf("SIGILL = %d\n", SIGILL);
	printf("SIGSEGV = %d\n", SIGSEGV);
	printf("SIGBUS = %d\n", SIGBUS);
	printf("SIGABRT = %d\n", SIGABRT);
	printf("SIGIOT = %d\n", SIGIOT);
	printf("SIGTRAP = %d\n", SIGTRAP);
	//printf("SIGEMT = %d\n", SIGEMT);
	printf("SIGSYS = %d\n", SIGSYS);

	return 0;
}
