# bash/zsh completion support for core Git.
#
# Copyright (C) 2006,2007 Shawn O. Pearce <spearce@spearce.org>
# Conceptually based on cleancompletion (http://cleanweb.hawaga.org.uk/).
# Distributed under the GNU General Public License, version 2.0.
#
# The contained completion routines provide support for completing:
#
#    *) local and remote branch names
#    *) local and remote tag names
#    *) .clean/remotes file names
#    *) clean 'subcommands'
#    *) tree paths within 'ref:path/to/file' expressions
#    *) file paths within current working directory and index
#    *) common --long-options
#
# To use these routines:
#
#    1) Copy this file to somewhere (e.g. ~/.clean-completion.sh).
#    2) Add the following line to your .bashrc/.zshrc:
#        source ~/.clean-completion.sh
#    3) Consider changing your PS1 to also show the current branch,
#       see clean-prompt.sh for details.

case "$COMP_WORDBREAKS" in
*:*) : great ;;
*)   COMP_WORDBREAKS="$COMP_WORDBREAKS:"
esac

# __cleandir accepts 0 or 1 arguments (i.e., location)
# returns location of .clean repo
__cleandir ()
{
	# Note: this function is duplicated in clean-prompt.sh
	# When updating it, make sure you update the other one to match.
	if [ -z "${1-}" ]; then
		if [ -n "${__clean_dir-}" ]; then
			echo "$__clean_dir"
		elif [ -n "${CLEAN_DIR-}" ]; then
			test -d "${CLEAN_DIR-}" || return 1
			echo "$CLEAN_DIR"
		elif [ -d .clean ]; then
			echo .clean
		else
			clean rev-parse --clean-dir 2>/dev/null
		fi
	elif [ -d "$1/.clean" ]; then
		echo "$1/.clean"
	else
		echo "$1"
	fi
}

# The following function is based on code from:
#
#   bash_completion - programmable completion functions for bash 3.2+
#
#   Copyright © 2006-2008, Ian Macdonald <ian@caliban.org>
#             © 2009-2010, Bash Completion Maintainers
#                     <bash-completion-devel@lists.alioth.debian.org>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2, or (at your option)
#   any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software Foundation,
#   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#   The latest version of this software can be obtained here:
#
#   http://bash-completion.alioth.debian.org/
#
#   RELEASE: 2.x

# This function can be used to access a tokenized list of words
# on the command line:
#
#	__clean_reassemble_comp_words_by_ref '=:'
#	if test "${words_[cword_-1]}" = -w
#	then
#		...
#	fi
#
# The argument should be a collection of characters from the list of
# word completion separators (COMP_WORDBREAKS) to treat as ordinary
# characters.
#
# This is roughly equivalent to going back in time and setting
# COMP_WORDBREAKS to exclude those characters.  The intent is to
# make option types like --date=<type> and <rev>:<path> easy to
# recognize by treating each shell word as a single token.
#
# It is best not to set COMP_WORDBREAKS directly because the value is
# shared with other completion scripts.  By the time the completion
# function gets called, COMP_WORDS has already been populated so local
# changes to COMP_WORDBREAKS have no effect.
#
# Output: words_, cword_, cur_.

__clean_reassemble_comp_words_by_ref()
{
	local exclude i j first
	# Which word separators to exclude?
	exclude="${1//[^$COMP_WORDBREAKS]}"
	cword_=$COMP_CWORD
	if [ -z "$exclude" ]; then
		words_=("${COMP_WORDS[@]}")
		return
	fi
	# List of word completion separators has shrunk;
	# re-assemble words to complete.
	for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++)); do
		# Append each nonempty word consisting of just
		# word separator characters to the current word.
		first=t
		while
			[ $i -gt 0 ] &&
			[ -n "${COMP_WORDS[$i]}" ] &&
			# word consists of excluded word separators
			[ "${COMP_WORDS[$i]//[^$exclude]}" = "${COMP_WORDS[$i]}" ]
		do
			# Attach to the previous token,
			# unless the previous token is the command name.
			if [ $j -ge 2 ] && [ -n "$first" ]; then
				((j--))
			fi
			first=
			words_[$j]=${words_[j]}${COMP_WORDS[i]}
			if [ $i = $COMP_CWORD ]; then
				cword_=$j
			fi
			if (($i < ${#COMP_WORDS[@]} - 1)); then
				((i++))
			else
				# Done.
				return
			fi
		done
		words_[$j]=${words_[j]}${COMP_WORDS[i]}
		if [ $i = $COMP_CWORD ]; then
			cword_=$j
		fi
	done
}

if ! type _get_comp_words_by_ref >/dev/null 2>&1; then
_get_comp_words_by_ref ()
{
	local exclude cur_ words_ cword_
	if [ "$1" = "-n" ]; then
		exclude=$2
		shift 2
	fi
	__clean_reassemble_comp_words_by_ref "$exclude"
	cur_=${words_[cword_]}
	while [ $# -gt 0 ]; do
		case "$1" in
		cur)
			cur=$cur_
			;;
		prev)
			prev=${words_[$cword_-1]}
			;;
		words)
			words=("${words_[@]}")
			;;
		cword)
			cword=$cword_
			;;
		esac
		shift
	done
}
fi

__cleancompadd ()
{
	local i=0
	for x in $1; do
		if [[ "$x" == "$3"* ]]; then
			COMPREPLY[i++]="$2$x$4"
		fi
	done
}

# Generates completion reply, appending a space to possible completion words,
# if necessary.
# It accepts 1 to 4 arguments:
# 1: List of possible completion words.
# 2: A prefix to be added to each possible completion word (optional).
# 3: Generate possible completion matches for this word (optional).
# 4: A suffix to be appended to each possible completion word (optional).
__cleancomp ()
{
	local cur_="${3-$cur}"

	case "$cur_" in
	--*=)
		;;
	*)
		local c i=0 IFS=$' \t\n'
		for c in $1; do
			c="$c${4-}"
			if [[ $c == "$cur_"* ]]; then
				case $c in
				--*=*|*.) ;;
				*) c="$c " ;;
				esac
				COMPREPLY[i++]="${2-}$c"
			fi
		done
		;;
	esac
}

# Generates completion reply from newline-separated possible completion words
# by appending a space to all of them.
# It accepts 1 to 4 arguments:
# 1: List of possible completion words, separated by a single newline.
# 2: A prefix to be added to each possible completion word (optional).
# 3: Generate possible completion matches for this word (optional).
# 4: A suffix to be appended to each possible completion word instead of
#    the default space (optional).  If specified but empty, nothing is
#    appended.
__cleancomp_nl ()
{
	local IFS=$'\n'
	__cleancompadd "$1" "${2-}" "${3-$cur}" "${4- }"
}

# Generates completion reply with compgen from newline-separated possible
# completion filenames.
# It accepts 1 to 3 arguments:
# 1: List of possible completion filenames, separated by a single newline.
# 2: A directory prefix to be added to each possible completion filename
#    (optional).
# 3: Generate possible completion matches for this word (optional).
__cleancomp_file ()
{
	local IFS=$'\n'

	# XXX does not work when the directory prefix contains a tilde,
	# since tilde expansion is not applied.
	# This means that COMPREPLY will be empty and Bash default
	# completion will be used.
	COMPREPLY=($(compgen -P "${2-}" -W "$1" -- "${3-$cur}"))

	# Tell Bash that compspec generates filenames.
	compopt -o filenames 2>/dev/null
}

__clean_index_file_list_filter_compat ()
{
	local path

	while read -r path; do
		case "$path" in
		?*/*) echo "${path%%/*}/" ;;
		*) echo "$path" ;;
		esac
	done
}

__clean_index_file_list_filter_bash ()
{
	local path

	while read -r path; do
		case "$path" in
		?*/*)
			# XXX if we append a slash to directory names when using
			# `compopt -o filenames`, Bash will append another slash.
			# This is pretty stupid, and this the reason why we have to
			# define a compatible version for this function.
			echo "${path%%/*}" ;;
		*)
			echo "$path" ;;
		esac
	done
}

# Process path list returned by "ls-files" and "diff-index --name-only"
# commands, in order to list only file names relative to a specified
# directory, and append a slash to directory names.
__clean_index_file_list_filter ()
{
	# Default to Bash >= 4.x
	__clean_index_file_list_filter_bash
}

# Execute clean ls-files, returning paths relative to the directory
# specified in the first argument, and using the options specified in
# the second argument.
__clean_ls_files_helper ()
{
	(
		test -n "${CDPATH+set}" && unset CDPATH
		# NOTE: $2 is not quoted in order to support multiple options
		cd "$1" && clean ls-files --exclude-standard $2
	) 2>/dev/null
}


# Execute clean diff-index, returning paths relative to the directory
# specified in the first argument, and using the tree object id
# specified in the second argument.
__clean_diff_index_helper ()
{
	(
		test -n "${CDPATH+set}" && unset CDPATH
		cd "$1" && clean diff-index --name-only --relative "$2"
	) 2>/dev/null
}

# __clean_index_files accepts 1 or 2 arguments:
# 1: Options to pass to ls-files (required).
#    Supported options are --cached, --modified, --deleted, --others,
#    and --directory.
# 2: A directory path (optional).
#    If provided, only files within the specified directory are listed.
#    Sub directories are never recursed.  Path must have a trailing
#    slash.
__clean_index_files ()
{
	local dir="$(__cleandir)" root="${2-.}"

	if [ -d "$dir" ]; then
		__clean_ls_files_helper "$root" "$1" | __clean_index_file_list_filter |
			sort | uniq
	fi
}

# __clean_diff_index_files accepts 1 or 2 arguments:
# 1) The id of a tree object.
# 2) A directory path (optional).
#    If provided, only files within the specified directory are listed.
#    Sub directories are never recursed.  Path must have a trailing
#    slash.
__clean_diff_index_files ()
{
	local dir="$(__cleandir)" root="${2-.}"

	if [ -d "$dir" ]; then
		__clean_diff_index_helper "$root" "$1" | __clean_index_file_list_filter |
			sort | uniq
	fi
}

__clean_heads ()
{
	local dir="$(__cleandir)"
	if [ -d "$dir" ]; then
		clean --clean-dir="$dir" for-each-ref --format='%(refname:short)' \
			refs/heads
		return
	fi
}

__clean_tags ()
{
	local dir="$(__cleandir)"
	if [ -d "$dir" ]; then
		clean --clean-dir="$dir" for-each-ref --format='%(refname:short)' \
			refs/tags
		return
	fi
}

# __clean_refs accepts 0, 1 (to pass to __cleandir), or 2 arguments
# presence of 2nd argument means use the guess heuristic employed
# by checkout for tracking branches
__clean_refs ()
{
	local i hash dir="$(__cleandir "${1-}")" track="${2-}"
	local format refs
	if [ -d "$dir" ]; then
		case "$cur" in
		refs|refs/*)
			format="refname"
			refs="${cur%/*}"
			track=""
			;;
		*)
			for i in HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD; do
				if [ -e "$dir/$i" ]; then echo $i; fi
			done
			format="refname:short"
			refs="refs/tags refs/heads refs/remotes"
			;;
		esac
		clean --clean-dir="$dir" for-each-ref --format="%($format)" \
			$refs
		if [ -n "$track" ]; then
			# employ the heuristic used by clean checkout
			# Try to find a remote branch that matches the completion word
			# but only output if the branch name is unique
			local ref entry
			clean --clean-dir="$dir" for-each-ref --shell --format="ref=%(refname:short)" \
				"refs/remotes/" | \
			while read -r entry; do
				eval "$entry"
				ref="${ref#*/}"
				if [[ "$ref" == "$cur"* ]]; then
					echo "$ref"
				fi
			done | sort | uniq -u
		fi
		return
	fi
	case "$cur" in
	refs|refs/*)
		clean ls-remote "$dir" "$cur*" 2>/dev/null | \
		while read -r hash i; do
			case "$i" in
			*^{}) ;;
			*) echo "$i" ;;
			esac
		done
		;;
	*)
		clean ls-remote "$dir" HEAD ORIG_HEAD 'refs/tags/*' 'refs/heads/*' 'refs/remotes/*' 2>/dev/null | \
		while read -r hash i; do
			case "$i" in
			*^{}) ;;
			refs/*) echo "${i#refs/*/}" ;;
			*) echo "$i" ;;
			esac
		done
		;;
	esac
}

# __clean_refs2 requires 1 argument (to pass to __clean_refs)
__clean_refs2 ()
{
	local i
	for i in $(__clean_refs "$1"); do
		echo "$i:$i"
	done
}

# __clean_refs_remotes requires 1 argument (to pass to ls-remote)
__clean_refs_remotes ()
{
	local i hash
	clean ls-remote "$1" 'refs/heads/*' 2>/dev/null | \
	while read -r hash i; do
		echo "$i:refs/remotes/$1/${i#refs/heads/}"
	done
}

__clean_remotes ()
{
	local i IFS=$'\n' d="$(__cleandir)"
	test -d "$d/remotes" && ls -1 "$d/remotes"
	for i in $(clean --clean-dir="$d" config --get-regexp 'remote\..*\.url' 2>/dev/null); do
		i="${i#remote.}"
		echo "${i/.url*/}"
	done
}

__clean_list_merge_strategies ()
{
	clean merge -s help 2>&1 |
	sed -n -e '/[Aa]vailable strategies are: /,/^$/{
		s/\.$//
		s/.*://
		s/^[ 	]*//
		s/[ 	]*$//
		p
	}'
}

__clean_merge_strategies=
# 'clean merge -s help' (and thus detection of the merge strategy
# list) fails, unfortunately, if run outside of any clean working
# tree.  __clean_merge_strategies is set to the empty string in
# that case, and the detection will be repeated the next time it
# is needed.
__clean_compute_merge_strategies ()
{
	test -n "$__clean_merge_strategies" ||
	__clean_merge_strategies=$(__clean_list_merge_strategies)
}

__clean_complete_revlist_file ()
{
	local pfx ls ref cur_="$cur"
	case "$cur_" in
	*..?*:*)
		return
		;;
	?*:*)
		ref="${cur_%%:*}"
		cur_="${cur_#*:}"
		case "$cur_" in
		?*/*)
			pfx="${cur_%/*}"
			cur_="${cur_##*/}"
			ls="$ref:$pfx"
			pfx="$pfx/"
			;;
		*)
			ls="$ref"
			;;
		esac

		case "$COMP_WORDBREAKS" in
		*:*) : great ;;
		*)   pfx="$ref:$pfx" ;;
		esac

		__cleancomp_nl "$(clean --clean-dir="$(__cleandir)" ls-tree "$ls" 2>/dev/null \
				| sed '/^100... blob /{
				           s,^.*	,,
				           s,$, ,
				       }
				       /^120000 blob /{
				           s,^.*	,,
				           s,$, ,
				       }
				       /^040000 tree /{
				           s,^.*	,,
				           s,$,/,
				       }
				       s/^.*	//')" \
			"$pfx" "$cur_" ""
		;;
	*...*)
		pfx="${cur_%...*}..."
		cur_="${cur_#*...}"
		__cleancomp_nl "$(__clean_refs)" "$pfx" "$cur_"
		;;
	*..*)
		pfx="${cur_%..*}.."
		cur_="${cur_#*..}"
		__cleancomp_nl "$(__clean_refs)" "$pfx" "$cur_"
		;;
	*)
		__cleancomp_nl "$(__clean_refs)"
		;;
	esac
}


# __clean_complete_index_file requires 1 argument: the options to pass to
# ls-file
__clean_complete_index_file ()
{
	local pfx cur_="$cur"

	case "$cur_" in
	?*/*)
		pfx="${cur_%/*}"
		cur_="${cur_##*/}"
		pfx="${pfx}/"

		__cleancomp_file "$(__clean_index_files "$1" "$pfx")" "$pfx" "$cur_"
		;;
	*)
		__cleancomp_file "$(__clean_index_files "$1")" "" "$cur_"
		;;
	esac
}

# __clean_complete_diff_index_file requires 1 argument: the id of a tree
# object
__clean_complete_diff_index_file ()
{
	local pfx cur_="$cur"

	case "$cur_" in
	?*/*)
		pfx="${cur_%/*}"
		cur_="${cur_##*/}"
		pfx="${pfx}/"

		__cleancomp_file "$(__clean_diff_index_files "$1" "$pfx")" "$pfx" "$cur_"
		;;
	*)
		__cleancomp_file "$(__clean_diff_index_files "$1")" "" "$cur_"
		;;
	esac
}

__clean_complete_file ()
{
	__clean_complete_revlist_file
}

__clean_complete_revlist ()
{
	__clean_complete_revlist_file
}

__clean_complete_remote_or_refspec ()
{
	local cur_="$cur" cmd="${words[1]}"
	local i c=2 remote="" pfx="" lhs=1 no_complete_refspec=0
	if [ "$cmd" = "remote" ]; then
		((c++))
	fi
	while [ $c -lt $cword ]; do
		i="${words[c]}"
		case "$i" in
		--mirror) [ "$cmd" = "push" ] && no_complete_refspec=1 ;;
		--all)
			case "$cmd" in
			push) no_complete_refspec=1 ;;
			fetch)
				return
				;;
			*) ;;
			esac
			;;
		-*) ;;
		*) remote="$i"; break ;;
		esac
		((c++))
	done
	if [ -z "$remote" ]; then
		__cleancomp_nl "$(__clean_remotes)"
		return
	fi
	if [ $no_complete_refspec = 1 ]; then
		return
	fi
	[ "$remote" = "." ] && remote=
	case "$cur_" in
	*:*)
		case "$COMP_WORDBREAKS" in
		*:*) : great ;;
		*)   pfx="${cur_%%:*}:" ;;
		esac
		cur_="${cur_#*:}"
		lhs=0
		;;
	+*)
		pfx="+"
		cur_="${cur_#+}"
		;;
	esac
	case "$cmd" in
	fetch)
		if [ $lhs = 1 ]; then
			__cleancomp_nl "$(__clean_refs2 "$remote")" "$pfx" "$cur_"
		else
			__cleancomp_nl "$(__clean_refs)" "$pfx" "$cur_"
		fi
		;;
	pull|remote)
		if [ $lhs = 1 ]; then
			__cleancomp_nl "$(__clean_refs "$remote")" "$pfx" "$cur_"
		else
			__cleancomp_nl "$(__clean_refs)" "$pfx" "$cur_"
		fi
		;;
	push)
		if [ $lhs = 1 ]; then
			__cleancomp_nl "$(__clean_refs)" "$pfx" "$cur_"
		else
			__cleancomp_nl "$(__clean_refs "$remote")" "$pfx" "$cur_"
		fi
		;;
	esac
}

__clean_complete_strategy ()
{
	__clean_compute_merge_strategies
	case "$prev" in
	-s|--strategy)
		__cleancomp "$__clean_merge_strategies"
		return 0
	esac
	case "$cur" in
	--strategy=*)
		__cleancomp "$__clean_merge_strategies" "" "${cur##--strategy=}"
		return 0
		;;
	esac
	return 1
}

__clean_commands () {
	if test -n "${CLEAN_TESTING_COMMAND_COMPLETION:-}"
	then
		printf "%s" "${CLEAN_TESTING_COMMAND_COMPLETION}"
	else
		clean help -a|egrep '^  [a-zA-Z0-9]'
	fi
}

__clean_list_all_commands ()
{
	local i IFS=" "$'\n'
	for i in $(__clean_commands)
	do
		case $i in
		*--*)             : helper pattern;;
		*) echo $i;;
		esac
	done
}

__clean_all_commands=
__clean_compute_all_commands ()
{
	test -n "$__clean_all_commands" ||
	__clean_all_commands=$(__clean_list_all_commands)
}

__clean_list_porcelain_commands ()
{
	local i IFS=" "$'\n'
	__clean_compute_all_commands
	for i in $__clean_all_commands
	do
		case $i in
		*--*)             : helper pattern;;
		applymbox)        : ask cleantus;;
		applypatch)       : ask cleantus;;
		archimport)       : import;;
		cat-file)         : plumbing;;
		check-attr)       : plumbing;;
		check-ignore)     : plumbing;;
		check-ref-format) : plumbing;;
		checkout-index)   : plumbing;;
		commit-tree)      : plumbing;;
		count-objects)    : infrequent;;
		credential-cache) : credentials helper;;
		credential-store) : credentials helper;;
		cvsexportcommit)  : export;;
		cvsimport)        : import;;
		cvsserver)        : daemon;;
		daemon)           : daemon;;
		diff-files)       : plumbing;;
		diff-index)       : plumbing;;
		diff-tree)        : plumbing;;
		fast-import)      : import;;
		fast-export)      : export;;
		fsck-objects)     : plumbing;;
		fetch-pack)       : plumbing;;
		fmt-merge-msg)    : plumbing;;
		for-each-ref)     : plumbing;;
		hash-object)      : plumbing;;
		http-*)           : transport;;
		index-pack)       : plumbing;;
		init-db)          : deprecated;;
		local-fetch)      : plumbing;;
		lost-found)       : infrequent;;
		ls-files)         : plumbing;;
		ls-remote)        : plumbing;;
		ls-tree)          : plumbing;;
		mailinfo)         : plumbing;;
		mailsplit)        : plumbing;;
		merge-*)          : plumbing;;
		mktree)           : plumbing;;
		mktag)            : plumbing;;
		pack-objects)     : plumbing;;
		pack-redundant)   : plumbing;;
		pack-refs)        : plumbing;;
		parse-remote)     : plumbing;;
		patch-id)         : plumbing;;
		peek-remote)      : plumbing;;
		prune)            : plumbing;;
		prune-packed)     : plumbing;;
		quiltimport)      : import;;
		read-tree)        : plumbing;;
		receive-pack)     : plumbing;;
		remote-*)         : transport;;
		repo-config)      : deprecated;;
		rerere)           : plumbing;;
		rev-list)         : plumbing;;
		rev-parse)        : plumbing;;
		runstatus)        : plumbing;;
		sh-setup)         : internal;;
		shell)            : daemon;;
		show-ref)         : plumbing;;
		send-pack)        : plumbing;;
		show-index)       : plumbing;;
		ssh-*)            : transport;;
		stripspace)       : plumbing;;
		symbolic-ref)     : plumbing;;
		tar-tree)         : deprecated;;
		unpack-file)      : plumbing;;
		unpack-objects)   : plumbing;;
		update-index)     : plumbing;;
		update-ref)       : plumbing;;
		update-server-info) : daemon;;
		upload-archive)   : plumbing;;
		upload-pack)      : plumbing;;
		write-tree)       : plumbing;;
		var)              : infrequent;;
		verify-pack)      : infrequent;;
		verify-tag)       : plumbing;;
		*) echo $i;;
		esac
	done
}

__clean_porcelain_commands=
__clean_compute_porcelain_commands ()
{
	__clean_compute_all_commands
	test -n "$__clean_porcelain_commands" ||
	__clean_porcelain_commands=$(__clean_list_porcelain_commands)
}

__clean_pretty_aliases ()
{
	local i IFS=$'\n'
	for i in $(clean --clean-dir="$(__cleandir)" config --get-regexp "pretty\..*" 2>/dev/null); do
		case "$i" in
		pretty.*)
			i="${i#pretty.}"
			echo "${i/ */}"
			;;
		esac
	done
}

__clean_aliases ()
{
	local i IFS=$'\n'
	for i in $(clean --clean-dir="$(__cleandir)" config --get-regexp "alias\..*" 2>/dev/null); do
		case "$i" in
		alias.*)
			i="${i#alias.}"
			echo "${i/ */}"
			;;
		esac
	done
}

# __clean_aliased_command requires 1 argument
__clean_aliased_command ()
{
	local word cmdline=$(clean --clean-dir="$(__cleandir)" \
		config --get "alias.$1")
	for word in $cmdline; do
		case "$word" in
		\!cleank|cleank)
			echo "cleank"
			return
			;;
		\!*)	: shell command alias ;;
		-*)	: option ;;
		*=*)	: setting env ;;
		clean)	: clean itself ;;
		*)
			echo "$word"
			return
		esac
	done
}

# __clean_find_on_cmdline requires 1 argument
__clean_find_on_cmdline ()
{
	local word subcommand c=1
	while [ $c -lt $cword ]; do
		word="${words[c]}"
		for subcommand in $1; do
			if [ "$subcommand" = "$word" ]; then
				echo "$subcommand"
				return
			fi
		done
		((c++))
	done
}

__clean_has_doubledash ()
{
	local c=1
	while [ $c -lt $cword ]; do
		if [ "--" = "${words[c]}" ]; then
			return 0
		fi
		((c++))
	done
	return 1
}

# Try to count non option arguments passed on the command line for the
# specified clean command.
# When options are used, it is necessary to use the special -- option to
# tell the implementation were non option arguments begin.
# XXX this can not be improved, since options can appear everywhere, as
# an example:
#	clean mv x -n y
#
# __clean_count_arguments requires 1 argument: the clean command executed.
__clean_count_arguments ()
{
	local word i c=0

	# Skip "clean" (first argument)
	for ((i=1; i < ${#words[@]}; i++)); do
		word="${words[i]}"

		case "$word" in
			--)
				# Good; we can assume that the following are only non
				# option arguments.
				((c = 0))
				;;
			"$1")
				# Skip the specified clean command and discard clean
				# main options
				((c = 0))
				;;
			?*)
				((c++))
				;;
		esac
	done

	printf "%d" $c
}

__clean_whitespacelist="nowarn warn error error-all fix"

_clean_am ()
{
	local dir="$(__cleandir)"
	if [ -d "$dir"/rebase-apply ]; then
		__cleancomp "--skip --continue --resolved --abort"
		return
	fi
	case "$cur" in
	--whitespace=*)
		__cleancomp "$__clean_whitespacelist" "" "${cur##--whitespace=}"
		return
		;;
	--*)
		__cleancomp "
			--3way --committer-date-is-author-date --ignore-date
			--ignore-whitespace --ignore-space-change
			--interactive --keep --no-utf8 --signoff --utf8
			--whitespace= --scissors
			"
		return
	esac
}

_clean_apply ()
{
	case "$cur" in
	--whitespace=*)
		__cleancomp "$__clean_whitespacelist" "" "${cur##--whitespace=}"
		return
		;;
	--*)
		__cleancomp "
			--stat --numstat --summary --check --index
			--cached --index-info --reverse --reject --unidiff-zero
			--apply --no-add --exclude=
			--ignore-whitespace --ignore-space-change
			--whitespace= --inaccurate-eof --verbose
			"
		return
	esac
}

_clean_add ()
{
	case "$cur" in
	--*)
		__cleancomp "
			--interactive --refresh --patch --update --dry-run
			--ignore-errors --intent-to-add
			"
		return
	esac

	# XXX should we check for --update and --all options ?
	__clean_complete_index_file "--others --modified"
}

_clean_archive ()
{
	case "$cur" in
	--format=*)
		__cleancomp "$(clean archive --list)" "" "${cur##--format=}"
		return
		;;
	--remote=*)
		__cleancomp_nl "$(__clean_remotes)" "" "${cur##--remote=}"
		return
		;;
	--*)
		__cleancomp "
			--format= --list --verbose
			--prefix= --remote= --exec=
			"
		return
		;;
	esac
	__clean_complete_file
}

_clean_bisect ()
{
	__clean_has_doubledash && return

	local subcommands="start bad good skip reset visualize replay log run"
	local subcommand="$(__clean_find_on_cmdline "$subcommands")"
	if [ -z "$subcommand" ]; then
		if [ -f "$(__cleandir)"/BISECT_START ]; then
			__cleancomp "$subcommands"
		else
			__cleancomp "replay start"
		fi
		return
	fi

	case "$subcommand" in
	bad|good|reset|skip|start)
		__cleancomp_nl "$(__clean_refs)"
		;;
	*)
		;;
	esac
}

_clean_branch ()
{
	local i c=1 only_local_ref="n" has_r="n"

	while [ $c -lt $cword ]; do
		i="${words[c]}"
		case "$i" in
		-d|-m)	only_local_ref="y" ;;
		-r)	has_r="y" ;;
		esac
		((c++))
	done

	case "$cur" in
	--set-upstream-to=*)
		__cleancomp "$(__clean_refs)" "" "${cur##--set-upstream-to=}"
		;;
	--*)
		__cleancomp "
			--color --no-color --verbose --abbrev= --no-abbrev
			--track --no-track --contains --merged --no-merged
			--set-upstream-to= --edit-description --list
			--unset-upstream
			"
		;;
	*)
		if [ $only_local_ref = "y" -a $has_r = "n" ]; then
			__cleancomp_nl "$(__clean_heads)"
		else
			__cleancomp_nl "$(__clean_refs)"
		fi
		;;
	esac
}

_clean_bundle ()
{
	local cmd="${words[2]}"
	case "$cword" in
	2)
		__cleancomp "create list-heads verify unbundle"
		;;
	3)
		# looking for a file
		;;
	*)
		case "$cmd" in
			create)
				__clean_complete_revlist
			;;
		esac
		;;
	esac
}

_clean_checkout ()
{
	__clean_has_doubledash && return

	case "$cur" in
	--conflict=*)
		__cleancomp "diff3 merge" "" "${cur##--conflict=}"
		;;
	--*)
		__cleancomp "
			--quiet --ours --theirs --track --no-track --merge
			--conflict= --orphan --patch
			"
		;;
	*)
		# check if --track, --no-track, or --no-guess was specified
		# if so, disable DWIM mode
		local flags="--track --no-track --no-guess" track=1
		if [ -n "$(__clean_find_on_cmdline "$flags")" ]; then
			track=''
		fi
		__cleancomp_nl "$(__clean_refs '' $track)"
		;;
	esac
}

_clean_cherry ()
{
	__cleancomp "$(__clean_refs)"
}

_clean_cherry_pick ()
{
	local dir="$(__cleandir)"
	if [ -f "$dir"/CHERRY_PICK_HEAD ]; then
		__cleancomp "--continue --quit --abort"
		return
	fi
	case "$cur" in
	--*)
		__cleancomp "--edit --no-commit --signoff --strategy= --mainline"
		;;
	*)
		__cleancomp_nl "$(__clean_refs)"
		;;
	esac
}

_clean_clean ()
{
	case "$cur" in
	--*)
		__cleancomp "--dry-run --quiet"
		return
		;;
	esac

	# XXX should we check for -x option ?
	__clean_complete_index_file "--others"
}

_clean_clone ()
{
	case "$cur" in
	--*)
		__cleancomp "
			--local
			--no-hardlinks
			--shared
			--reference
			--quiet
			--no-checkout
			--bare
			--mirror
			--origin
			--upload-pack
			--template=
			--depth
			--single-branch
			--branch
			"
		return
		;;
	esac
}

_clean_commit ()
{
	case "$prev" in
	-c|-C)
		__cleancomp_nl "$(__clean_refs)" "" "${cur}"
		return
		;;
	esac

	case "$cur" in
	--cleanup=*)
		__cleancomp "default strip verbatim whitespace
			" "" "${cur##--cleanup=}"
		return
		;;
	--reuse-message=*|--reedit-message=*|\
	--fixup=*|--squash=*)
		__cleancomp_nl "$(__clean_refs)" "" "${cur#*=}"
		return
		;;
	--untracked-files=*)
		__cleancomp "all no normal" "" "${cur##--untracked-files=}"
		return
		;;
	--*)
		__cleancomp "
			--all --author= --signoff --verify --no-verify
			--edit --no-edit
			--amend --include --only --interactive
			--dry-run --reuse-message= --reedit-message=
			--reset-author --file= --message= --template=
			--cleanup= --untracked-files --untracked-files=
			--verbose --quiet --fixup= --squash=
			"
		return
	esac

	if clean rev-parse --verify --quiet HEAD >/dev/null; then
		__clean_complete_diff_index_file "HEAD"
	else
		# This is the first commit
		__clean_complete_index_file "--cached"
	fi
}

_clean_describe ()
{
	case "$cur" in
	--*)
		__cleancomp "
			--all --tags --contains --abbrev= --candidates=
			--exact-match --debug --long --match --always
			"
		return
	esac
	__cleancomp_nl "$(__clean_refs)"
}

__clean_diff_algorithms="myers minimal patience histogram"

__clean_diff_common_options="--stat --numstat --shortstat --summary
			--patch-with-stat --name-only --name-status --color
			--no-color --color-words --no-renames --check
			--full-index --binary --abbrev --diff-filter=
			--find-copies-harder
			--text --ignore-space-at-eol --ignore-space-change
			--ignore-all-space --exit-code --quiet --ext-diff
			--no-ext-diff
			--no-prefix --src-prefix= --dst-prefix=
			--inter-hunk-context=
			--patience --histogram --minimal
			--raw
			--dirstat --dirstat= --dirstat-by-file
			--dirstat-by-file= --cumulative
			--diff-algorithm=
"

_clean_diff ()
{
	__clean_has_doubledash && return

	case "$cur" in
	--diff-algorithm=*)
		__cleancomp "$__clean_diff_algorithms" "" "${cur##--diff-algorithm=}"
		return
		;;
	--*)
		__cleancomp "--cached --staged --pickaxe-all --pickaxe-regex
			--base --ours --theirs --no-index
			$__clean_diff_common_options
			"
		return
		;;
	esac
	__clean_complete_revlist_file
}

__clean_mergetools_common="diffuse ecmerge emerge kdiff3 meld opendiff
			tkdiff vimdiff gvimdiff xxdiff araxis p4merge bc3 codecompare
"

_clean_difftool ()
{
	__clean_has_doubledash && return

	case "$cur" in
	--tool=*)
		__cleancomp "$__clean_mergetools_common kompare" "" "${cur##--tool=}"
		return
		;;
	--*)
		__cleancomp "--cached --staged --pickaxe-all --pickaxe-regex
			--base --ours --theirs
			--no-renames --diff-filter= --find-copies-harder
			--relative --ignore-submodules
			--tool="
		return
		;;
	esac
	__clean_complete_file
}

__clean_fetch_options="
	--quiet --verbose --append --upload-pack --force --keep --depth=
	--tags --no-tags --all --prune --dry-run
"

_clean_fetch ()
{
	case "$cur" in
	--*)
		__cleancomp "$__clean_fetch_options"
		return
		;;
	esac
	__clean_complete_remote_or_refspec
}

__clean_format_patch_options="
	--stdout --attach --no-attach --thread --thread= --no-thread
	--numbered --start-number --numbered-files --keep-subject --signoff
	--signature --no-signature --in-reply-to= --cc= --full-index --binary
	--not --all --cover-letter --no-prefix --src-prefix= --dst-prefix=
	--inline --suffix= --ignore-if-in-upstream --subject-prefix=
	--output-directory --reroll-count --to= --quiet --notes
"

_clean_format_patch ()
{
	case "$cur" in
	--thread=*)
		__cleancomp "
			deep shallow
			" "" "${cur##--thread=}"
		return
		;;
	--*)
		__cleancomp "$__clean_format_patch_options"
		return
		;;
	esac
	__clean_complete_revlist
}

_clean_fsck ()
{
	case "$cur" in
	--*)
		__cleancomp "
			--tags --root --unreachable --cache --no-reflogs --full
			--strict --verbose --lost-found
			"
		return
		;;
	esac
}

_clean_gc ()
{
	case "$cur" in
	--*)
		__cleancomp "--prune --aggressive"
		return
		;;
	esac
}

_clean_cleank ()
{
	_cleank
}

__clean_match_ctag() {
	awk "/^${1////\\/}/ { print \$1 }" "$2"
}

_clean_grep ()
{
	__clean_has_doubledash && return

	case "$cur" in
	--*)
		__cleancomp "
			--cached
			--text --ignore-case --word-regexp --invert-match
			--full-name --line-number
			--extended-regexp --basic-regexp --fixed-strings
			--perl-regexp
			--files-with-matches --name-only
			--files-without-match
			--max-depth
			--count
			--and --or --not --all-match
			"
		return
		;;
	esac

	case "$cword,$prev" in
	2,*|*,-*)
		if test -r tags; then
			__cleancomp_nl "$(__clean_match_ctag "$cur" tags)"
			return
		fi
		;;
	esac

	__cleancomp_nl "$(__clean_refs)"
}

_clean_help ()
{
	case "$cur" in
	--*)
		__cleancomp "--all --info --man --web"
		return
		;;
	esac
	__clean_compute_all_commands
	__cleancomp "$__clean_all_commands $(__clean_aliases)
		attributes cli core-tutorial cvs-migration
		diffcore cleank glossary hooks ignore modules
		namespaces repository-layout tutorial tutorial-2
		workflows
		"
}

_clean_init ()
{
	case "$cur" in
	--shared=*)
		__cleancomp "
			false true umask group all world everybody
			" "" "${cur##--shared=}"
		return
		;;
	--*)
		__cleancomp "--quiet --bare --template= --shared --shared="
		return
		;;
	esac
}

_clean_ls_files ()
{
	case "$cur" in
	--*)
		__cleancomp "--cached --deleted --modified --others --ignored
			--stage --directory --no-empty-directory --unmerged
			--killed --exclude= --exclude-from=
			--exclude-per-directory= --exclude-standard
			--error-unmatch --with-tree= --full-name
			--abbrev --ignored --exclude-per-directory
			"
		return
		;;
	esac

	# XXX ignore options like --modified and always suggest all cached
	# files.
	__clean_complete_index_file "--cached"
}

_clean_ls_remote ()
{
	__cleancomp_nl "$(__clean_remotes)"
}

_clean_ls_tree ()
{
	__clean_complete_file
}

# Options that go well for log, shortlog and cleank
__clean_log_common_options="
	--not --all
	--branches --tags --remotes
	--first-parent --merges --no-merges
	--max-count=
	--max-age= --since= --after=
	--min-age= --until= --before=
	--min-parents= --max-parents=
	--no-min-parents --no-max-parents
"
# Options that go well for log and cleank (not shortlog)
__clean_log_cleank_options="
	--dense --sparse --full-history
	--simplify-merges --simplify-by-decoration
	--left-right --notes --no-notes
"
# Options that go well for log and shortlog (not cleank)
__clean_log_shortlog_options="
	--author= --committer= --grep=
	--all-match
"

__clean_log_pretty_formats="oneline short medium full fuller email raw format:"
__clean_log_date_formats="relative iso8601 rfc2822 short local default raw"

_clean_log ()
{
	__clean_has_doubledash && return

	local g="$(clean rev-parse --clean-dir 2>/dev/null)"
	local merge=""
	if [ -f "$g/MERGE_HEAD" ]; then
		merge="--merge"
	fi
	case "$cur" in
	--pretty=*|--format=*)
		__cleancomp "$__clean_log_pretty_formats $(__clean_pretty_aliases)
			" "" "${cur#*=}"
		return
		;;
	--date=*)
		__cleancomp "$__clean_log_date_formats" "" "${cur##--date=}"
		return
		;;
	--decorate=*)
		__cleancomp "long short" "" "${cur##--decorate=}"
		return
		;;
	--*)
		__cleancomp "
			$__clean_log_common_options
			$__clean_log_shortlog_options
			$__clean_log_cleank_options
			--root --topo-order --date-order --reverse
			--follow --full-diff
			--abbrev-commit --abbrev=
			--relative-date --date=
			--pretty= --format= --oneline
			--cherry-pick
			--graph
			--decorate --decorate=
			--walk-reflogs
			--parents --children
			$merge
			$__clean_diff_common_options
			--pickaxe-all --pickaxe-regex
			"
		return
		;;
	esac
	__clean_complete_revlist
}

__clean_merge_options="
	--no-commit --no-stat --log --no-log --squash --strategy
	--commit --stat --no-squash --ff --no-ff --ff-only --edit --no-edit
"

_clean_merge ()
{
	__clean_complete_strategy && return

	case "$cur" in
	--*)
		__cleancomp "$__clean_merge_options"
		return
	esac
	__cleancomp_nl "$(__clean_refs)"
}

_clean_mergetool ()
{
	case "$cur" in
	--tool=*)
		__cleancomp "$__clean_mergetools_common tortoisemerge" "" "${cur##--tool=}"
		return
		;;
	--*)
		__cleancomp "--tool="
		return
		;;
	esac
}

_clean_merge_base ()
{
	__cleancomp_nl "$(__clean_refs)"
}

_clean_mv ()
{
	case "$cur" in
	--*)
		__cleancomp "--dry-run"
		return
		;;
	esac

	if [ $(__clean_count_arguments "mv") -gt 0 ]; then
		# We need to show both cached and untracked files (including
		# empty directories) since this may not be the last argument.
		__clean_complete_index_file "--cached --others --directory"
	else
		__clean_complete_index_file "--cached"
	fi
}

_clean_name_rev ()
{
	__cleancomp "--tags --all --stdin"
}

_clean_notes ()
{
	local subcommands='add append copy edit list prune remove show'
	local subcommand="$(__clean_find_on_cmdline "$subcommands")"

	case "$subcommand,$cur" in
	,--*)
		__cleancomp '--ref'
		;;
	,*)
		case "$prev" in
		--ref)
			__cleancomp_nl "$(__clean_refs)"
			;;
		*)
			__cleancomp "$subcommands --ref"
			;;
		esac
		;;
	add,--reuse-message=*|append,--reuse-message=*|\
	add,--reedit-message=*|append,--reedit-message=*)
		__cleancomp_nl "$(__clean_refs)" "" "${cur#*=}"
		;;
	add,--*|append,--*)
		__cleancomp '--file= --message= --reedit-message=
				--reuse-message='
		;;
	copy,--*)
		__cleancomp '--stdin'
		;;
	prune,--*)
		__cleancomp '--dry-run --verbose'
		;;
	prune,*)
		;;
	*)
		case "$prev" in
		-m|-F)
			;;
		*)
			__cleancomp_nl "$(__clean_refs)"
			;;
		esac
		;;
	esac
}

_clean_pull ()
{
	__clean_complete_strategy && return

	case "$cur" in
	--*)
		__cleancomp "
			--rebase --no-rebase
			$__clean_merge_options
			$__clean_fetch_options
		"
		return
		;;
	esac
	__clean_complete_remote_or_refspec
}

_clean_push ()
{
	case "$prev" in
	--repo)
		__cleancomp_nl "$(__clean_remotes)"
		return
	esac
	case "$cur" in
	--repo=*)
		__cleancomp_nl "$(__clean_remotes)" "" "${cur##--repo=}"
		return
		;;
	--*)
		__cleancomp "
			--all --mirror --tags --dry-run --force --verbose
			--receive-pack= --repo= --set-upstream
		"
		return
		;;
	esac
	__clean_complete_remote_or_refspec
}

_clean_rebase ()
{
	local dir="$(__cleandir)"
	if [ -d "$dir"/rebase-apply ] || [ -d "$dir"/rebase-merge ]; then
		__cleancomp "--continue --skip --abort"
		return
	fi
	__clean_complete_strategy && return
	case "$cur" in
	--whitespace=*)
		__cleancomp "$__clean_whitespacelist" "" "${cur##--whitespace=}"
		return
		;;
	--*)
		__cleancomp "
			--onto --merge --strategy --interactive
			--preserve-merges --stat --no-stat
			--committer-date-is-author-date --ignore-date
			--ignore-whitespace --whitespace=
			--autosquash
			"

		return
	esac
	__cleancomp_nl "$(__clean_refs)"
}

_clean_reflog ()
{
	local subcommands="show delete expire"
	local subcommand="$(__clean_find_on_cmdline "$subcommands")"

	if [ -z "$subcommand" ]; then
		__cleancomp "$subcommands"
	else
		__cleancomp_nl "$(__clean_refs)"
	fi
}

__clean_send_email_confirm_options="always never auto cc compose"
__clean_send_email_suppresscc_options="author self cc bodycc sob cccmd body all"

_clean_send_email ()
{
	case "$cur" in
	--confirm=*)
		__cleancomp "
			$__clean_send_email_confirm_options
			" "" "${cur##--confirm=}"
		return
		;;
	--suppress-cc=*)
		__cleancomp "
			$__clean_send_email_suppresscc_options
			" "" "${cur##--suppress-cc=}"

		return
		;;
	--smtp-encryption=*)
		__cleancomp "ssl tls" "" "${cur##--smtp-encryption=}"
		return
		;;
	--thread=*)
		__cleancomp "
			deep shallow
			" "" "${cur##--thread=}"
		return
		;;
	--*)
		__cleancomp "--annotate --bcc --cc --cc-cmd --chain-reply-to
			--compose --confirm= --dry-run --envelope-sender
			--from --identity
			--in-reply-to --no-chain-reply-to --no-signed-off-by-cc
			--no-suppress-from --no-thread --quiet
			--signed-off-by-cc --smtp-pass --smtp-server
			--smtp-server-port --smtp-encryption= --smtp-user
			--subject --suppress-cc= --suppress-from --thread --to
			--validate --no-validate
			$__clean_format_patch_options"
		return
		;;
	esac
	__clean_complete_revlist
}

_clean_stage ()
{
	_clean_add
}

__clean_config_get_set_variables ()
{
	local prevword word config_file= c=$cword
	while [ $c -gt 1 ]; do
		word="${words[c]}"
		case "$word" in
		--system|--global|--local|--file=*)
			config_file="$word"
			break
			;;
		-f|--file)
			config_file="$word $prevword"
			break
			;;
		esac
		prevword=$word
		c=$((--c))
	done

	clean --clean-dir="$(__cleandir)" config $config_file --list 2>/dev/null |
	while read -r line
	do
		case "$line" in
		*.*=*)
			echo "${line/=*/}"
			;;
		esac
	done
}

_clean_config ()
{
	case "$prev" in
	branch.*.remote|branch.*.pushremote)
		__cleancomp_nl "$(__clean_remotes)"
		return
		;;
	branch.*.merge)
		__cleancomp_nl "$(__clean_refs)"
		return
		;;
	branch.*.rebase)
		__cleancomp "false true"
		return
		;;
	remote.pushdefault)
		__cleancomp_nl "$(__clean_remotes)"
		return
		;;
	remote.*.fetch)
		local remote="${prev#remote.}"
		remote="${remote%.fetch}"
		if [ -z "$cur" ]; then
			__cleancomp_nl "refs/heads/" "" "" ""
			return
		fi
		__cleancomp_nl "$(__clean_refs_remotes "$remote")"
		return
		;;
	remote.*.push)
		local remote="${prev#remote.}"
		remote="${remote%.push}"
		__cleancomp_nl "$(clean --clean-dir="$(__cleandir)" \
			for-each-ref --format='%(refname):%(refname)' \
			refs/heads)"
		return
		;;
	pull.twohead|pull.octopus)
		__clean_compute_merge_strategies
		__cleancomp "$__clean_merge_strategies"
		return
		;;
	color.branch|color.diff|color.interactive|\
	color.showbranch|color.status|color.ui)
		__cleancomp "always never auto"
		return
		;;
	color.pager)
		__cleancomp "false true"
		return
		;;
	color.*.*)
		__cleancomp "
			normal black red green yellow blue magenta cyan white
			bold dim ul blink reverse
			"
		return
		;;
	diff.submodule)
		__cleancomp "log short"
		return
		;;
	help.format)
		__cleancomp "man info web html"
		return
		;;
	log.date)
		__cleancomp "$__clean_log_date_formats"
		return
		;;
	sendemail.aliasesfiletype)
		__cleancomp "mutt mailrc pine elm gnus"
		return
		;;
	sendemail.confirm)
		__cleancomp "$__clean_send_email_confirm_options"
		return
		;;
	sendemail.suppresscc)
		__cleancomp "$__clean_send_email_suppresscc_options"
		return
		;;
	--get|--get-all|--unset|--unset-all)
		__cleancomp_nl "$(__clean_config_get_set_variables)"
		return
		;;
	*.*)
		return
		;;
	esac
	case "$cur" in
	--*)
		__cleancomp "
			--system --global --local --file=
			--list --replace-all
			--get --get-all --get-regexp
			--add --unset --unset-all
			--remove-section --rename-section
			"
		return
		;;
	branch.*.*)
		local pfx="${cur%.*}." cur_="${cur##*.}"
		__cleancomp "remote pushremote merge mergeoptions rebase" "$pfx" "$cur_"
		return
		;;
	branch.*)
		local pfx="${cur%.*}." cur_="${cur#*.}"
		__cleancomp_nl "$(__clean_heads)" "$pfx" "$cur_" "."
		return
		;;
	guitool.*.*)
		local pfx="${cur%.*}." cur_="${cur##*.}"
		__cleancomp "
			argprompt cmd confirm needsfile noconsole norescan
			prompt revprompt revunmerged title
			" "$pfx" "$cur_"
		return
		;;
	difftool.*.*)
		local pfx="${cur%.*}." cur_="${cur##*.}"
		__cleancomp "cmd path" "$pfx" "$cur_"
		return
		;;
	man.*.*)
		local pfx="${cur%.*}." cur_="${cur##*.}"
		__cleancomp "cmd path" "$pfx" "$cur_"
		return
		;;
	mergetool.*.*)
		local pfx="${cur%.*}." cur_="${cur##*.}"
		__cleancomp "cmd path trustExitCode" "$pfx" "$cur_"
		return
		;;
	pager.*)
		local pfx="${cur%.*}." cur_="${cur#*.}"
		__clean_compute_all_commands
		__cleancomp_nl "$__clean_all_commands" "$pfx" "$cur_"
		return
		;;
	remote.*.*)
		local pfx="${cur%.*}." cur_="${cur##*.}"
		__cleancomp "
			url proxy fetch push mirror skipDefaultUpdate
			receivepack uploadpack tagopt pushurl
			" "$pfx" "$cur_"
		return
		;;
	remote.*)
		local pfx="${cur%.*}." cur_="${cur#*.}"
		__cleancomp_nl "$(__clean_remotes)" "$pfx" "$cur_" "."
		return
		;;
	url.*.*)
		local pfx="${cur%.*}." cur_="${cur##*.}"
		__cleancomp "insteadOf pushInsteadOf" "$pfx" "$cur_"
		return
		;;
	esac
	__cleancomp "
		add.ignoreErrors
		advice.commitBeforeMerge
		advice.detachedHead
		advice.implicitIdentity
		advice.pushNonFastForward
		advice.resolveConflict
		advice.statusHints
		alias.
		am.keepcr
		apply.ignorewhitespace
		apply.whitespace
		branch.autosetupmerge
		branch.autosetuprebase
		browser.
		clean.requireForce
		color.branch
		color.branch.current
		color.branch.local
		color.branch.plain
		color.branch.remote
		color.decorate.HEAD
		color.decorate.branch
		color.decorate.remoteBranch
		color.decorate.stash
		color.decorate.tag
		color.diff
		color.diff.commit
		color.diff.frag
		color.diff.func
		color.diff.meta
		color.diff.new
		color.diff.old
		color.diff.plain
		color.diff.whitespace
		color.grep
		color.grep.context
		color.grep.filename
		color.grep.function
		color.grep.linenumber
		color.grep.match
		color.grep.selected
		color.grep.separator
		color.interactive
		color.interactive.error
		color.interactive.header
		color.interactive.help
		color.interactive.prompt
		color.pager
		color.showbranch
		color.status
		color.status.added
		color.status.changed
		color.status.header
		color.status.nobranch
		color.status.untracked
		color.status.updated
		color.ui
		commit.status
		commit.template
		core.abbrev
		core.askpass
		core.attributesfile
		core.autocrlf
		core.bare
		core.bigFileThreshold
		core.compression
		core.createObject
		core.deltaBaseCacheLimit
		core.editor
		core.eol
		core.excludesfile
		core.fileMode
		core.fsyncobjectfiles
		core.cleanProxy
		core.ignoreCygwinFSTricks
		core.ignoreStat
		core.ignorecase
		core.logAllRefUpdates
		core.loosecompression
		core.notesRef
		core.packedGitLimit
		core.packedGitWindowSize
		core.pager
		core.preferSymlinkRefs
		core.preloadindex
		core.quotepath
		core.repositoryFormatVersion
		core.safecrlf
		core.sharedRepository
		core.sparseCheckout
		core.symlinks
		core.trustctime
		core.warnAmbiguousRefs
		core.whitespace
		core.worktree
		diff.autorefreshindex
		diff.external
		diff.ignoreSubmodules
		diff.mnemonicprefix
		diff.noprefix
		diff.renameLimit
		diff.renames
		diff.statGraphWidth
		diff.submodule
		diff.suppressBlankEmpty
		diff.tool
		diff.wordRegex
		diff.algorithm
		difftool.
		difftool.prompt
		fetch.recurseSubmodules
		fetch.unpackLimit
		format.attach
		format.cc
		format.headers
		format.numbered
		format.pretty
		format.signature
		format.signoff
		format.subjectprefix
		format.suffix
		format.thread
		format.to
		gc.
		gc.aggressiveWindow
		gc.auto
		gc.autopacklimit
		gc.packrefs
		gc.pruneexpire
		gc.reflogexpire
		gc.reflogexpireunreachable
		gc.rerereresolved
		gc.rerereunresolved
		cleancvs.allbinary
		cleancvs.commitmsgannotation
		cleancvs.dbTableNamePrefix
		cleancvs.dbdriver
		cleancvs.dbname
		cleancvs.dbpass
		cleancvs.dbuser
		cleancvs.enabled
		cleancvs.logfile
		cleancvs.usecrlfattr
		guitool.
		gui.blamehistoryctx
		gui.commitmsgwidth
		gui.copyblamethreshold
		gui.diffcontext
		gui.encoding
		gui.fastcopyblame
		gui.matchtrackingbranch
		gui.newbranchtemplate
		gui.pruneduringfetch
		gui.spellingdictionary
		gui.trustmtime
		help.autocorrect
		help.browser
		help.format
		http.lowSpeedLimit
		http.lowSpeedTime
		http.maxRequests
		http.minSessions
		http.noEPSV
		http.postBuffer
		http.proxy
		http.sslCAInfo
		http.sslCAPath
		http.sslCert
		http.sslCertPasswordProtected
		http.sslKey
		http.sslVerify
		http.useragent
		i18n.commitEncoding
		i18n.logOutputEncoding
		imap.authMethod
		imap.folder
		imap.host
		imap.pass
		imap.port
		imap.preformattedHTML
		imap.sslverify
		imap.tunnel
		imap.user
		init.templatedir
		instaweb.browser
		instaweb.httpd
		instaweb.local
		instaweb.modulepath
		instaweb.port
		interactive.singlekey
		log.date
		log.decorate
		log.showroot
		mailmap.file
		man.
		man.viewer
		merge.
		merge.conflictstyle
		merge.log
		merge.renameLimit
		merge.renormalize
		merge.stat
		merge.tool
		merge.verbosity
		mergetool.
		mergetool.keepBackup
		mergetool.keepTemporaries
		mergetool.prompt
		notes.displayRef
		notes.rewrite.
		notes.rewrite.amend
		notes.rewrite.rebase
		notes.rewriteMode
		notes.rewriteRef
		pack.compression
		pack.deltaCacheLimit
		pack.deltaCacheSize
		pack.depth
		pack.indexVersion
		pack.packSizeLimit
		pack.threads
		pack.window
		pack.windowMemory
		pager.
		pretty.
		pull.octopus
		pull.twohead
		push.default
		rebase.autosquash
		rebase.stat
		receive.autogc
		receive.denyCurrentBranch
		receive.denyDeleteCurrent
		receive.denyDeletes
		receive.denyNonFastForwards
		receive.fsckObjects
		receive.unpackLimit
		receive.updateserverinfo
		remote.pushdefault
		remotes.
		repack.usedeltabaseoffset
		rerere.autoupdate
		rerere.enabled
		sendemail.
		sendemail.aliasesfile
		sendemail.aliasfiletype
		sendemail.bcc
		sendemail.cc
		sendemail.cccmd
		sendemail.chainreplyto
		sendemail.confirm
		sendemail.envelopesender
		sendemail.from
		sendemail.identity
		sendemail.multiedit
		sendemail.signedoffbycc
		sendemail.smtpdomain
		sendemail.smtpencryption
		sendemail.smtppass
		sendemail.smtpserver
		sendemail.smtpserveroption
		sendemail.smtpserverport
		sendemail.smtpuser
		sendemail.suppresscc
		sendemail.suppressfrom
		sendemail.thread
		sendemail.to
		sendemail.validate
		showbranch.default
		status.relativePaths
		status.showUntrackedFiles
		status.submodulesummary
		submodule.
		tar.umask
		transfer.unpackLimit
		url.
		user.email
		user.name
		user.signingkey
		web.browser
		branch. remote.
	"
}

_clean_remote ()
{
	local subcommands="add rename remove set-head set-branches set-url show prune update"
	local subcommand="$(__clean_find_on_cmdline "$subcommands")"
	if [ -z "$subcommand" ]; then
		__cleancomp "$subcommands"
		return
	fi

	case "$subcommand" in
	rename|remove|set-url|show|prune)
		__cleancomp_nl "$(__clean_remotes)"
		;;
	set-head|set-branches)
		__clean_complete_remote_or_refspec
		;;
	update)
		local i c='' IFS=$'\n'
		for i in $(clean --clean-dir="$(__cleandir)" config --get-regexp "remotes\..*" 2>/dev/null); do
			i="${i#remotes.}"
			c="$c ${i/ */}"
		done
		__cleancomp "$c"
		;;
	*)
		;;
	esac
}

_clean_replace ()
{
	__cleancomp_nl "$(__clean_refs)"
}

_clean_reset ()
{
	__clean_has_doubledash && return

	case "$cur" in
	--*)
		__cleancomp "--merge --mixed --hard --soft --patch"
		return
		;;
	esac
	__cleancomp_nl "$(__clean_refs)"
}

_clean_revert ()
{
	case "$cur" in
	--*)
		__cleancomp "--edit --mainline --no-edit --no-commit --signoff"
		return
		;;
	esac
	__cleancomp_nl "$(__clean_refs)"
}

_clean_rm ()
{
	case "$cur" in
	--*)
		__cleancomp "--cached --dry-run --ignore-unmatch --quiet"
		return
		;;
	esac

	__clean_complete_index_file "--cached"
}

_clean_shortlog ()
{
	__clean_has_doubledash && return

	case "$cur" in
	--*)
		__cleancomp "
			$__clean_log_common_options
			$__clean_log_shortlog_options
			--numbered --summary
			"
		return
		;;
	esac
	__clean_complete_revlist
}

_clean_show ()
{
	__clean_has_doubledash && return

	case "$cur" in
	--pretty=*|--format=*)
		__cleancomp "$__clean_log_pretty_formats $(__clean_pretty_aliases)
			" "" "${cur#*=}"
		return
		;;
	--diff-algorithm=*)
		__cleancomp "$__clean_diff_algorithms" "" "${cur##--diff-algorithm=}"
		return
		;;
	--*)
		__cleancomp "--pretty= --format= --abbrev-commit --oneline
			$__clean_diff_common_options
			"
		return
		;;
	esac
	__clean_complete_file
}

_clean_show_branch ()
{
	case "$cur" in
	--*)
		__cleancomp "
			--all --remotes --topo-order --current --more=
			--list --independent --merge-base --no-name
			--color --no-color
			--sha1-name --sparse --topics --reflog
			"
		return
		;;
	esac
	__clean_complete_revlist
}

_clean_stash ()
{
	local save_opts='--keep-index --no-keep-index --quiet --patch'
	local subcommands='save list show apply clear drop pop create branch'
	local subcommand="$(__clean_find_on_cmdline "$subcommands")"
	if [ -z "$subcommand" ]; then
		case "$cur" in
		--*)
			__cleancomp "$save_opts"
			;;
		*)
			if [ -z "$(__clean_find_on_cmdline "$save_opts")" ]; then
				__cleancomp "$subcommands"
			fi
			;;
		esac
	else
		case "$subcommand,$cur" in
		save,--*)
			__cleancomp "$save_opts"
			;;
		apply,--*|pop,--*)
			__cleancomp "--index --quiet"
			;;
		show,--*|drop,--*|branch,--*)
			;;
		show,*|apply,*|drop,*|pop,*|branch,*)
			__cleancomp_nl "$(clean --clean-dir="$(__cleandir)" stash list \
					| sed -n -e 's/:.*//p')"
			;;
		*)
			;;
		esac
	fi
}

_clean_submodule ()
{
	__clean_has_doubledash && return

	local subcommands="add status init deinit update summary foreach sync"
	if [ -z "$(__clean_find_on_cmdline "$subcommands")" ]; then
		case "$cur" in
		--*)
			__cleancomp "--quiet --cached"
			;;
		*)
			__cleancomp "$subcommands"
			;;
		esac
		return
	fi
}

_clean_svn ()
{
	local subcommands="
		init fetch clone rebase dcommit log find-rev
		set-tree commit-diff info create-ignore propget
		proplist show-ignore show-externals branch tag blame
		migrate mkdirs reset gc
		"
	local subcommand="$(__clean_find_on_cmdline "$subcommands")"
	if [ -z "$subcommand" ]; then
		__cleancomp "$subcommands"
	else
		local remote_opts="--username= --config-dir= --no-auth-cache"
		local fc_opts="
			--follow-parent --authors-file= --repack=
			--no-metadata --use-svm-props --use-svnsync-props
			--log-window-size= --no-checkout --quiet
			--repack-flags --use-log-author --localtime
			--ignore-paths= --include-paths= $remote_opts
			"
		local init_opts="
			--template= --shared= --trunk= --tags=
			--branches= --stdlayout --minimize-url
			--no-metadata --use-svm-props --use-svnsync-props
			--rewrite-root= --prefix= --use-log-author
			--add-author-from $remote_opts
			"
		local cmt_opts="
			--edit --rmdir --find-copies-harder --copy-similarity=
			"

		case "$subcommand,$cur" in
		fetch,--*)
			__cleancomp "--revision= --fetch-all $fc_opts"
			;;
		clone,--*)
			__cleancomp "--revision= $fc_opts $init_opts"
			;;
		init,--*)
			__cleancomp "$init_opts"
			;;
		dcommit,--*)
			__cleancomp "
				--merge --strategy= --verbose --dry-run
				--fetch-all --no-rebase --commit-url
				--revision --interactive $cmt_opts $fc_opts
				"
			;;
		set-tree,--*)
			__cleancomp "--stdin $cmt_opts $fc_opts"
			;;
		create-ignore,--*|propget,--*|proplist,--*|show-ignore,--*|\
		show-externals,--*|mkdirs,--*)
			__cleancomp "--revision="
			;;
		log,--*)
			__cleancomp "
				--limit= --revision= --verbose --incremental
				--oneline --show-commit --non-recursive
				--authors-file= --color
				"
			;;
		rebase,--*)
			__cleancomp "
				--merge --verbose --strategy= --local
				--fetch-all --dry-run $fc_opts
				"
			;;
		commit-diff,--*)
			__cleancomp "--message= --file= --revision= $cmt_opts"
			;;
		info,--*)
			__cleancomp "--url"
			;;
		branch,--*)
			__cleancomp "--dry-run --message --tag"
			;;
		tag,--*)
			__cleancomp "--dry-run --message"
			;;
		blame,--*)
			__cleancomp "--clean-format"
			;;
		migrate,--*)
			__cleancomp "
				--config-dir= --ignore-paths= --minimize
				--no-auth-cache --username=
				"
			;;
		reset,--*)
			__cleancomp "--revision= --parent"
			;;
		*)
			;;
		esac
	fi
}

_clean_tag ()
{
	local i c=1 f=0
	while [ $c -lt $cword ]; do
		i="${words[c]}"
		case "$i" in
		-d|-v)
			__cleancomp_nl "$(__clean_tags)"
			return
			;;
		-f)
			f=1
			;;
		esac
		((c++))
	done

	case "$prev" in
	-m|-F)
		;;
	-*|tag)
		if [ $f = 1 ]; then
			__cleancomp_nl "$(__clean_tags)"
		fi
		;;
	*)
		__cleancomp_nl "$(__clean_refs)"
		;;
	esac
}

_clean_whatchanged ()
{
	_clean_log
}

__clean_main ()
{
	local i c=1 command __clean_dir

	while [ $c -lt $cword ]; do
		i="${words[c]}"
		case "$i" in
		--clean-dir=*) __clean_dir="${i#--clean-dir=}" ;;
		--bare)      __clean_dir="." ;;
		--help) command="help"; break ;;
		-c) c=$((++c)) ;;
		-*) ;;
		*) command="$i"; break ;;
		esac
		((c++))
	done

	if [ -z "$command" ]; then
		case "$cur" in
		--*)   __cleancomp "
			--paginate
			--no-pager
			--clean-dir=
			--bare
			--version
			--exec-path
			--exec-path=
			--html-path
			--info-path
			--work-tree=
			--namespace=
			--no-replace-objects
			--help
			"
			;;
		*)     __clean_compute_porcelain_commands
		       __cleancomp "$__clean_porcelain_commands $(__clean_aliases)" ;;
		esac
		return
	fi

	local completion_func="_clean_${command//-/_}"
	declare -f $completion_func >/dev/null && $completion_func && return

	local expansion=$(__clean_aliased_command "$command")
	if [ -n "$expansion" ]; then
		completion_func="_clean_${expansion//-/_}"
		declare -f $completion_func >/dev/null && $completion_func
	fi
}

__cleank_main ()
{
	__clean_has_doubledash && return

	local g="$(__cleandir)"
	local merge=""
	if [ -f "$g/MERGE_HEAD" ]; then
		merge="--merge"
	fi
	case "$cur" in
	--*)
		__cleancomp "
			$__clean_log_common_options
			$__clean_log_cleank_options
			$merge
			"
		return
		;;
	esac
	__clean_complete_revlist
}

if [[ -n ${ZSH_VERSION-} ]]; then
	echo "WARNING: this script is deprecated, please see clean-completion.zsh" 1>&2

	autoload -U +X compinit && compinit

	__cleancomp ()
	{
		emulate -L zsh

		local cur_="${3-$cur}"

		case "$cur_" in
		--*=)
			;;
		*)
			local c IFS=$' \t\n'
			local -a array
			for c in ${=1}; do
				c="$c${4-}"
				case $c in
				--*=*|*.) ;;
				*) c="$c " ;;
				esac
				array[$#array+1]="$c"
			done
			compset -P '*[=:]'
			compadd -Q -S '' -p "${2-}" -a -- array && _ret=0
			;;
		esac
	}

	__cleancomp_nl ()
	{
		emulate -L zsh

		local IFS=$'\n'
		compset -P '*[=:]'
		compadd -Q -S "${4- }" -p "${2-}" -- ${=1} && _ret=0
	}

	__cleancomp_file ()
	{
		emulate -L zsh

		local IFS=$'\n'
		compset -P '*[=:]'
		compadd -Q -p "${2-}" -f -- ${=1} && _ret=0
	}

	__clean_zsh_helper ()
	{
		emulate -L ksh
		local cur cword prev
		cur=${words[CURRENT-1]}
		prev=${words[CURRENT-2]}
		let cword=CURRENT-1
		__${service}_main
	}

	_clean ()
	{
		emulate -L zsh
		local _ret=1
		__clean_zsh_helper
		let _ret && _default -S '' && _ret=0
		return _ret
	}

	compdef _clean clean cleank
	return
elif [[ -n ${BASH_VERSION-} ]]; then
	if ((${BASH_VERSINFO[0]} < 4)); then
		# compopt is not supported
		__clean_index_file_list_filter ()
		{
			__clean_index_file_list_filter_compat
		}
	fi
fi

__clean_func_wrap ()
{
	local cur words cword prev
	_get_comp_words_by_ref -n =: cur words cword prev
	$1
}

# Setup completion for certain functions defined above by setting common
# variables and workarounds.
# This is NOT a public function; use at your own risk.
__clean_complete ()
{
	local wrapper="__clean_wrap${2}"
	eval "$wrapper () { __clean_func_wrap $2 ; }"
	complete -o bashdefault -o default -o nospace -F $wrapper $1 2>/dev/null \
		|| complete -o default -o nospace -F $wrapper $1
}

# wrapper for backwards compatibility
_clean ()
{
	__clean_wrap__clean_main
}

# wrapper for backwards compatibility
_cleank ()
{
	__clean_wrap__cleank_main
}

__clean_complete clean __clean_main
__clean_complete cleank __cleank_main

# The following are necessary only for Cygwin, and only are needed
# when the user has tab-completed the executable name and consequently
# included the '.exe' suffix.
#
if [ Cygwin = "$(uname -o 2>/dev/null)" ]; then
__clean_complete clean.exe __clean_main
fi
